{
  "address": "0x2279B7A0a67DB372996a5FaB50D91eAA73d2eBe6",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_principal",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_ratio",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_n",
          "type": "uint256"
        }
      ],
      "name": "compound",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_principal",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_ratio",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_n",
          "type": "uint256"
        }
      ],
      "name": "compoundWithTopoff",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "int128",
          "name": "_x",
          "type": "int128"
        },
        {
          "internalType": "uint256",
          "name": "_n",
          "type": "uint256"
        }
      ],
      "name": "pow",
      "outputs": [
        {
          "internalType": "int128",
          "name": "",
          "type": "int128"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_totalDebt",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_fixedInterestRate",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_firIntervals",
          "type": "uint256"
        }
      ],
      "name": "topoff",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x2dda701a6781cce6ce9a5ab334f26da1ed4a3b3d64013daaad46204ffcd31bbf",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x2279B7A0a67DB372996a5FaB50D91eAA73d2eBe6",
    "transactionIndex": 0,
    "gasUsed": "377001",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xe6c1ea53bf634c56a7010cb0ebb7844a527c72e17b2f75f074b361e8084d841f",
    "transactionHash": "0x2dda701a6781cce6ce9a5ab334f26da1ed4a3b3d64013daaad46204ffcd31bbf",
    "logs": [],
    "blockNumber": 9,
    "cumulativeGasUsed": "377001",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "6026b98393f52c3678e3a85d9b556f4c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"compound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"compoundWithTopoff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int128\",\"name\":\"_x\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"pow\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"\",\"type\":\"int128\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fixedInterestRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_firIntervals\",\"type\":\"uint256\"}],\"name\":\"topoff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/LibLoanContract.sol\":\"LibLoanContractInterest\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"contracts/abdk-libraries-solidity/ABDKMath64x64.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math 64.64 Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with signed\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\n * represented by int128 type holding only the numerator.\\n */\\nlibrary ABDKMath64x64 {\\n    /*\\n     * Minimum value signed 64.64-bit fixed point number may have.\\n     */\\n    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\n\\n    /*\\n     * Maximum value signed 64.64-bit fixed point number may have.\\n     */\\n    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    /**\\n     * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\n     * number.  Revert on overflow.\\n     *\\n     * @param x signed 256-bit integer number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function fromInt(int256 x) internal pure returns (int128) {\\n        unchecked {\\n            require(x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\n            return int128(x << 64);\\n        }\\n    }\\n\\n    /**\\n     * Convert signed 64.64 fixed point number into signed 64-bit integer number\\n     * rounding down.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @return signed 64-bit integer number\\n     */\\n    function toInt(int128 x) internal pure returns (int64) {\\n        unchecked {\\n            return int64(x >> 64);\\n        }\\n    }\\n\\n    /**\\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\n     * number.  Revert on overflow.\\n     *\\n     * @param x unsigned 256-bit integer number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function fromUInt(uint256 x) internal pure returns (int128) {\\n        unchecked {\\n            require(x <= 0x7FFFFFFFFFFFFFFF);\\n            return int128(int256(x << 64));\\n        }\\n    }\\n\\n    /**\\n     * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\n     * number rounding down.  Revert on underflow.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @return unsigned 64-bit integer number\\n     */\\n    function toUInt(int128 x) internal pure returns (uint64) {\\n        unchecked {\\n            require(x >= 0);\\n            return uint64(uint128(x >> 64));\\n        }\\n    }\\n\\n    /**\\n     * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\n     * number rounding down.  Revert on overflow.\\n     *\\n     * @param x signed 128.128-bin fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function from128x128(int256 x) internal pure returns (int128) {\\n        unchecked {\\n            int256 result = x >> 64;\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\n            return int128(result);\\n        }\\n    }\\n\\n    /**\\n     * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\n     * number.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @return signed 128.128 fixed point number\\n     */\\n    function to128x128(int128 x) internal pure returns (int256) {\\n        unchecked {\\n            return int256(x) << 64;\\n        }\\n    }\\n\\n    /**\\n     * Calculate x + y.  Revert on overflow.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @param y signed 64.64-bit fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function add(int128 x, int128 y) internal pure returns (int128) {\\n        unchecked {\\n            int256 result = int256(x) + y;\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\n            return int128(result);\\n        }\\n    }\\n\\n    /**\\n     * Calculate x - y.  Revert on overflow.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @param y signed 64.64-bit fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function sub(int128 x, int128 y) internal pure returns (int128) {\\n        unchecked {\\n            int256 result = int256(x) - y;\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\n            return int128(result);\\n        }\\n    }\\n\\n    /**\\n     * Calculate x * y rounding down.  Revert on overflow.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @param y signed 64.64-bit fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function mul(int128 x, int128 y) internal pure returns (int128) {\\n        unchecked {\\n            int256 result = (int256(x) * y) >> 64;\\n            require(result >= MIN_64x64 && result <= MAX_64x64, \\\"fail\\\");\\n            return int128(result);\\n        }\\n    }\\n\\n    /**\\n     * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\n     * number and y is signed 256-bit integer number.  Revert on overflow.\\n     *\\n     * @param x signed 64.64 fixed point number\\n     * @param y signed 256-bit integer number\\n     * @return signed 256-bit integer number\\n     */\\n    function muli(int128 x, int256 y) internal pure returns (int256) {\\n        unchecked {\\n            if (x == MIN_64x64) {\\n                require(\\n                    y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\n                        y <= 0x1000000000000000000000000000000000000000000000000\\n                );\\n                return -y << 63;\\n            } else {\\n                bool negativeResult = false;\\n                if (x < 0) {\\n                    x = -x;\\n                    negativeResult = true;\\n                }\\n                if (y < 0) {\\n                    y = -y; // We rely on overflow behavior here\\n                    negativeResult = !negativeResult;\\n                }\\n                uint256 absoluteResult = mulu(x, uint256(y));\\n                if (negativeResult) {\\n                    require(\\n                        absoluteResult <=\\n                            0x8000000000000000000000000000000000000000000000000000000000000000\\n                    );\\n                    return -int256(absoluteResult); // We rely on overflow behavior here\\n                } else {\\n                    require(\\n                        absoluteResult <=\\n                            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                    );\\n                    return int256(absoluteResult);\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\\n     *\\n     * @param x signed 64.64 fixed point number\\n     * @param y unsigned 256-bit integer number\\n     * @return unsigned 256-bit integer number\\n     */\\n    function mulu(int128 x, uint256 y) internal pure returns (uint256) {\\n        unchecked {\\n            if (y == 0) return 0;\\n\\n            require(x >= 0);\\n\\n            uint256 lo = (uint256(int256(x)) *\\n                (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\n            uint256 hi = uint256(int256(x)) * (y >> 128);\\n\\n            require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n            hi <<= 64;\\n\\n            require(\\n                hi <=\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF -\\n                        lo\\n            );\\n            return hi + lo;\\n        }\\n    }\\n\\n    /**\\n     * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\n     * zero.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @param y signed 64.64-bit fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function div(int128 x, int128 y) internal pure returns (int128) {\\n        unchecked {\\n            require(y != 0);\\n            int256 result = (int256(x) << 64) / y;\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\n            return int128(result);\\n        }\\n    }\\n\\n    /**\\n     * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\n     * integer numbers.  Revert on overflow or when y is zero.\\n     *\\n     * @param x signed 256-bit integer number\\n     * @param y signed 256-bit integer number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function divi(int256 x, int256 y) internal pure returns (int128) {\\n        unchecked {\\n            require(y != 0);\\n\\n            bool negativeResult = false;\\n            if (x < 0) {\\n                x = -x; // We rely on overflow behavior here\\n                negativeResult = true;\\n            }\\n            if (y < 0) {\\n                y = -y; // We rely on overflow behavior here\\n                negativeResult = !negativeResult;\\n            }\\n            uint128 absoluteResult = divuu(uint256(x), uint256(y));\\n            if (negativeResult) {\\n                require(absoluteResult <= 0x80000000000000000000000000000000);\\n                return -int128(absoluteResult); // We rely on overflow behavior here\\n            } else {\\n                require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n                return int128(absoluteResult); // We rely on overflow behavior here\\n            }\\n        }\\n    }\\n\\n    /**\\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n     * integer numbers.  Revert on overflow or when y is zero.\\n     *\\n     * @param x unsigned 256-bit integer number\\n     * @param y unsigned 256-bit integer number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function divu(uint256 x, uint256 y) internal pure returns (int128) {\\n        unchecked {\\n            require(y != 0);\\n            uint128 result = divuu(x, y);\\n            require(result <= uint128(MAX_64x64));\\n            return int128(result);\\n        }\\n    }\\n\\n    /**\\n     * Calculate -x.  Revert on overflow.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function neg(int128 x) internal pure returns (int128) {\\n        unchecked {\\n            require(x != MIN_64x64);\\n            return -x;\\n        }\\n    }\\n\\n    /**\\n     * Calculate |x|.  Revert on overflow.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function abs(int128 x) internal pure returns (int128) {\\n        unchecked {\\n            require(x != MIN_64x64);\\n            return x < 0 ? -x : x;\\n        }\\n    }\\n\\n    /**\\n     * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\n     * zero.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function inv(int128 x) internal pure returns (int128) {\\n        unchecked {\\n            require(x != 0);\\n            int256 result = int256(0x100000000000000000000000000000000) / x;\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\n            return int128(result);\\n        }\\n    }\\n\\n    /**\\n     * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @param y signed 64.64-bit fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function avg(int128 x, int128 y) internal pure returns (int128) {\\n        unchecked {\\n            return int128((int256(x) + int256(y)) >> 1);\\n        }\\n    }\\n\\n    /**\\n     * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\n     * Revert on overflow or in case x * y is negative.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @param y signed 64.64-bit fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function gavg(int128 x, int128 y) internal pure returns (int128) {\\n        unchecked {\\n            int256 m = int256(x) * int256(y);\\n            require(m >= 0);\\n            require(\\n                m <\\n                    0x4000000000000000000000000000000000000000000000000000000000000000\\n            );\\n            return int128(sqrtu(uint256(m)));\\n        }\\n    }\\n\\n    /**\\n     * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @param y uint256 value\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function pow(int128 x, uint256 y) internal pure returns (int128) {\\n        unchecked {\\n            bool negative = x < 0 && y & 1 == 1;\\n\\n            uint256 absX = uint128(x < 0 ? -x : x);\\n            uint256 absResult;\\n            absResult = 0x100000000000000000000000000000000;\\n\\n            if (absX <= 0x10000000000000000) {\\n                absX <<= 63;\\n                while (y != 0) {\\n                    if (y & 0x1 != 0) {\\n                        absResult = (absResult * absX) >> 127;\\n                    }\\n                    absX = (absX * absX) >> 127;\\n\\n                    if (y & 0x2 != 0) {\\n                        absResult = (absResult * absX) >> 127;\\n                    }\\n                    absX = (absX * absX) >> 127;\\n\\n                    if (y & 0x4 != 0) {\\n                        absResult = (absResult * absX) >> 127;\\n                    }\\n                    absX = (absX * absX) >> 127;\\n\\n                    if (y & 0x8 != 0) {\\n                        absResult = (absResult * absX) >> 127;\\n                    }\\n                    absX = (absX * absX) >> 127;\\n\\n                    y >>= 4;\\n                }\\n\\n                absResult >>= 64;\\n            } else {\\n                uint256 absXShift = 63;\\n                if (absX < 0x1000000000000000000000000) {\\n                    absX <<= 32;\\n                    absXShift -= 32;\\n                }\\n                if (absX < 0x10000000000000000000000000000) {\\n                    absX <<= 16;\\n                    absXShift -= 16;\\n                }\\n                if (absX < 0x1000000000000000000000000000000) {\\n                    absX <<= 8;\\n                    absXShift -= 8;\\n                }\\n                if (absX < 0x10000000000000000000000000000000) {\\n                    absX <<= 4;\\n                    absXShift -= 4;\\n                }\\n                if (absX < 0x40000000000000000000000000000000) {\\n                    absX <<= 2;\\n                    absXShift -= 2;\\n                }\\n                if (absX < 0x80000000000000000000000000000000) {\\n                    absX <<= 1;\\n                    absXShift -= 1;\\n                }\\n\\n                uint256 resultShift = 0;\\n                while (y != 0) {\\n                    require(absXShift < 64);\\n\\n                    if (y & 0x1 != 0) {\\n                        absResult = (absResult * absX) >> 127;\\n                        resultShift += absXShift;\\n                        if (absResult > 0x100000000000000000000000000000000) {\\n                            absResult >>= 1;\\n                            resultShift += 1;\\n                        }\\n                    }\\n                    absX = (absX * absX) >> 127;\\n                    absXShift <<= 1;\\n                    if (absX >= 0x100000000000000000000000000000000) {\\n                        absX >>= 1;\\n                        absXShift += 1;\\n                    }\\n\\n                    y >>= 1;\\n                }\\n\\n                require(resultShift < 64);\\n                absResult >>= 64 - resultShift;\\n            }\\n            int256 result = negative ? -int256(absResult) : int256(absResult);\\n            require(result >= MIN_64x64 && result <= MAX_64x64);\\n            return int128(result);\\n        }\\n    }\\n\\n    /**\\n     * Calculate sqrt (x) rounding down.  Revert if x < 0.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function sqrt(int128 x) internal pure returns (int128) {\\n        unchecked {\\n            require(x >= 0);\\n            return int128(sqrtu(uint256(int256(x)) << 64));\\n        }\\n    }\\n\\n    /**\\n     * Calculate binary logarithm of x.  Revert if x <= 0.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function log_2(int128 x) internal pure returns (int128) {\\n        unchecked {\\n            require(x > 0);\\n\\n            int256 msb = 0;\\n            int256 xc = x;\\n            if (xc >= 0x10000000000000000) {\\n                xc >>= 64;\\n                msb += 64;\\n            }\\n            if (xc >= 0x100000000) {\\n                xc >>= 32;\\n                msb += 32;\\n            }\\n            if (xc >= 0x10000) {\\n                xc >>= 16;\\n                msb += 16;\\n            }\\n            if (xc >= 0x100) {\\n                xc >>= 8;\\n                msb += 8;\\n            }\\n            if (xc >= 0x10) {\\n                xc >>= 4;\\n                msb += 4;\\n            }\\n            if (xc >= 0x4) {\\n                xc >>= 2;\\n                msb += 2;\\n            }\\n            if (xc >= 0x2) msb += 1; // No need to shift xc anymore\\n\\n            int256 result = (msb - 64) << 64;\\n            uint256 ux = uint256(int256(x)) << uint256(127 - msb);\\n            for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\n                ux *= ux;\\n                uint256 b = ux >> 255;\\n                ux >>= 127 + b;\\n                result += bit * int256(b);\\n            }\\n\\n            return int128(result);\\n        }\\n    }\\n\\n    /**\\n     * Calculate natural logarithm of x.  Revert if x <= 0.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function ln(int128 x) internal pure returns (int128) {\\n        unchecked {\\n            require(x > 0);\\n\\n            return\\n                int128(\\n                    int256(\\n                        (uint256(int256(log_2(x))) *\\n                            0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128\\n                    )\\n                );\\n        }\\n    }\\n\\n    /**\\n     * Calculate binary exponent of x.  Revert on overflow.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function exp_2(int128 x) internal pure returns (int128) {\\n        unchecked {\\n            require(x < 0x400000000000000000); // Overflow\\n\\n            if (x < -0x400000000000000000) return 0; // Underflow\\n\\n            uint256 result = 0x80000000000000000000000000000000;\\n\\n            if (x & 0x8000000000000000 > 0)\\n                result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\\n            if (x & 0x4000000000000000 > 0)\\n                result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;\\n            if (x & 0x2000000000000000 > 0)\\n                result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;\\n            if (x & 0x1000000000000000 > 0)\\n                result = (result * 0x10B5586CF9890F6298B92B71842A98363) >> 128;\\n            if (x & 0x800000000000000 > 0)\\n                result = (result * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;\\n            if (x & 0x400000000000000 > 0)\\n                result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;\\n            if (x & 0x200000000000000 > 0)\\n                result = (result * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;\\n            if (x & 0x100000000000000 > 0)\\n                result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;\\n            if (x & 0x80000000000000 > 0)\\n                result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;\\n            if (x & 0x40000000000000 > 0)\\n                result = (result * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;\\n            if (x & 0x20000000000000 > 0)\\n                result = (result * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;\\n            if (x & 0x10000000000000 > 0)\\n                result = (result * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;\\n            if (x & 0x8000000000000 > 0)\\n                result = (result * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;\\n            if (x & 0x4000000000000 > 0)\\n                result = (result * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;\\n            if (x & 0x2000000000000 > 0)\\n                result = (result * 0x1000162E525EE054754457D5995292026) >> 128;\\n            if (x & 0x1000000000000 > 0)\\n                result = (result * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;\\n            if (x & 0x800000000000 > 0)\\n                result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;\\n            if (x & 0x400000000000 > 0)\\n                result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;\\n            if (x & 0x200000000000 > 0)\\n                result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\\n            if (x & 0x100000000000 > 0)\\n                result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\\n            if (x & 0x80000000000 > 0)\\n                result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;\\n            if (x & 0x40000000000 > 0)\\n                result = (result * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;\\n            if (x & 0x20000000000 > 0)\\n                result = (result * 0x100000162E430E5A18F6119E3C02282A5) >> 128;\\n            if (x & 0x10000000000 > 0)\\n                result = (result * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;\\n            if (x & 0x8000000000 > 0)\\n                result = (result * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;\\n            if (x & 0x4000000000 > 0)\\n                result = (result * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;\\n            if (x & 0x2000000000 > 0)\\n                result = (result * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;\\n            if (x & 0x1000000000 > 0)\\n                result = (result * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;\\n            if (x & 0x800000000 > 0)\\n                result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;\\n            if (x & 0x400000000 > 0)\\n                result = (result * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;\\n            if (x & 0x200000000 > 0)\\n                result = (result * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;\\n            if (x & 0x100000000 > 0)\\n                result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\\n            if (x & 0x80000000 > 0)\\n                result = (result * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;\\n            if (x & 0x40000000 > 0)\\n                result = (result * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;\\n            if (x & 0x20000000 > 0)\\n                result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\\n            if (x & 0x10000000 > 0)\\n                result = (result * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;\\n            if (x & 0x8000000 > 0)\\n                result = (result * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;\\n            if (x & 0x4000000 > 0)\\n                result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;\\n            if (x & 0x2000000 > 0)\\n                result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\\n            if (x & 0x1000000 > 0)\\n                result = (result * 0x10000000000B17217F7D20CF927C8E94C) >> 128;\\n            if (x & 0x800000 > 0)\\n                result = (result * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;\\n            if (x & 0x400000 > 0)\\n                result = (result * 0x100000000002C5C85FDF477B662B26945) >> 128;\\n            if (x & 0x200000 > 0)\\n                result = (result * 0x10000000000162E42FEFA3AE53369388C) >> 128;\\n            if (x & 0x100000 > 0)\\n                result = (result * 0x100000000000B17217F7D1D351A389D40) >> 128;\\n            if (x & 0x80000 > 0)\\n                result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;\\n            if (x & 0x40000 > 0)\\n                result = (result * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;\\n            if (x & 0x20000 > 0)\\n                result = (result * 0x100000000000162E42FEFA39FE95583C2) >> 128;\\n            if (x & 0x10000 > 0)\\n                result = (result * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;\\n            if (x & 0x8000 > 0)\\n                result = (result * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;\\n            if (x & 0x4000 > 0)\\n                result = (result * 0x10000000000002C5C85FDF473E242EA38) >> 128;\\n            if (x & 0x2000 > 0)\\n                result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;\\n            if (x & 0x1000 > 0)\\n                result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\\n            if (x & 0x800 > 0)\\n                result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\\n            if (x & 0x400 > 0)\\n                result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;\\n            if (x & 0x200 > 0)\\n                result = (result * 0x10000000000000162E42FEFA39EF44D91) >> 128;\\n            if (x & 0x100 > 0)\\n                result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;\\n            if (x & 0x80 > 0)\\n                result = (result * 0x10000000000000058B90BFBE8E7BCE544) >> 128;\\n            if (x & 0x40 > 0)\\n                result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\\n            if (x & 0x20 > 0)\\n                result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;\\n            if (x & 0x10 > 0)\\n                result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\\n            if (x & 0x8 > 0)\\n                result = (result * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;\\n            if (x & 0x4 > 0)\\n                result = (result * 0x10000000000000002C5C85FDF473DE6B2) >> 128;\\n            if (x & 0x2 > 0)\\n                result = (result * 0x1000000000000000162E42FEFA39EF358) >> 128;\\n            if (x & 0x1 > 0)\\n                result = (result * 0x10000000000000000B17217F7D1CF79AB) >> 128;\\n\\n            result >>= uint256(int256(63 - (x >> 64)));\\n            require(result <= uint256(int256(MAX_64x64)));\\n\\n            return int128(int256(result));\\n        }\\n    }\\n\\n    /**\\n     * Calculate natural exponent of x.  Revert on overflow.\\n     *\\n     * @param x signed 64.64-bit fixed point number\\n     * @return signed 64.64-bit fixed point number\\n     */\\n    function exp(int128 x) internal pure returns (int128) {\\n        unchecked {\\n            require(x < 0x400000000000000000); // Overflow\\n\\n            if (x < -0x400000000000000000) return 0; // Underflow\\n\\n            return\\n                exp_2(\\n                    int128(\\n                        (int256(x) * 0x171547652B82FE1777D0FFDA0D23A7D12) >> 128\\n                    )\\n                );\\n        }\\n    }\\n\\n    /**\\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n     * integer numbers.  Revert on overflow or when y is zero.\\n     *\\n     * @param x unsigned 256-bit integer number\\n     * @param y unsigned 256-bit integer number\\n     * @return unsigned 64.64-bit fixed point number\\n     */\\n    function divuu(uint256 x, uint256 y) private pure returns (uint128) {\\n        unchecked {\\n            require(y != 0);\\n\\n            uint256 result;\\n\\n            if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n                result = (x << 64) / y;\\n            else {\\n                uint256 msb = 192;\\n                uint256 xc = x >> 192;\\n                if (xc >= 0x100000000) {\\n                    xc >>= 32;\\n                    msb += 32;\\n                }\\n                if (xc >= 0x10000) {\\n                    xc >>= 16;\\n                    msb += 16;\\n                }\\n                if (xc >= 0x100) {\\n                    xc >>= 8;\\n                    msb += 8;\\n                }\\n                if (xc >= 0x10) {\\n                    xc >>= 4;\\n                    msb += 4;\\n                }\\n                if (xc >= 0x4) {\\n                    xc >>= 2;\\n                    msb += 2;\\n                }\\n                if (xc >= 0x2) msb += 1; // No need to shift xc anymore\\n\\n                result = (x << (255 - msb)) / (((y - 1) >> (msb - 191)) + 1);\\n                require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n                uint256 hi = result * (y >> 128);\\n                uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n                uint256 xh = x >> 192;\\n                uint256 xl = x << 64;\\n\\n                if (xl < lo) xh -= 1;\\n                xl -= lo; // We rely on overflow behavior here\\n                lo = hi << 128;\\n                if (xl < lo) xh -= 1;\\n                xl -= lo; // We rely on overflow behavior here\\n\\n                result += xh == hi >> 128 ? xl / y : 1;\\n            }\\n\\n            require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n            return uint128(result);\\n        }\\n    }\\n\\n    /**\\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n     * number.\\n     *\\n     * @param x unsigned 256-bit integer number\\n     * @return unsigned 128-bit integer number\\n     */\\n    function sqrtu(uint256 x) private pure returns (uint128) {\\n        unchecked {\\n            if (x == 0) return 0;\\n            else {\\n                uint256 xx = x;\\n                uint256 r = 1;\\n                if (xx >= 0x100000000000000000000000000000000) {\\n                    xx >>= 128;\\n                    r <<= 64;\\n                }\\n                if (xx >= 0x10000000000000000) {\\n                    xx >>= 64;\\n                    r <<= 32;\\n                }\\n                if (xx >= 0x100000000) {\\n                    xx >>= 32;\\n                    r <<= 16;\\n                }\\n                if (xx >= 0x10000) {\\n                    xx >>= 16;\\n                    r <<= 8;\\n                }\\n                if (xx >= 0x100) {\\n                    xx >>= 8;\\n                    r <<= 4;\\n                }\\n                if (xx >= 0x10) {\\n                    xx >>= 4;\\n                    r <<= 2;\\n                }\\n                if (xx >= 0x4) {\\n                    r <<= 1;\\n                }\\n                r = (r + x / r) >> 1;\\n                r = (r + x / r) >> 1;\\n                r = (r + x / r) >> 1;\\n                r = (r + x / r) >> 1;\\n                r = (r + x / r) >> 1;\\n                r = (r + x / r) >> 1;\\n                r = (r + x / r) >> 1; // Seven iterations should be enough\\n                uint256 r1 = x / r;\\n                return uint128(r < r1 ? r : r1);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6ea2ccc9d587551e1c92fe89efcca4e5376395bc43dd098865075f18fa6f09bd\",\"license\":\"BSD-4-Clause\"},\"contracts/domain/LoanContractFIRIntervals.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n/* ------------------------------------------------ *\\n *       Fixed Interest Rate (FIR) Intervals        *\\n * ------------------------------------------------ */\\n//  Need to validate duration > FIR interval\\nuint8 constant _SECONDLY_ = 0;\\nuint8 constant _MINUTELY_ = 1;\\nuint8 constant _HOURLY_ = 2;\\nuint8 constant _DAILY_ = 3;\\nuint8 constant _WEEKLY_ = 4;\\nuint8 constant _2_WEEKLY_ = 5;\\nuint8 constant _4_WEEKLY_ = 6;\\nuint8 constant _6_WEEKLY_ = 7;\\nuint8 constant _8_WEEKLY_ = 8;\\nuint8 constant _MONTHLY_ = 9;\\nuint8 constant _2_MONTHLY_ = 10;\\nuint8 constant _3_MONTHLY_ = 11;\\nuint8 constant _4_MONTHLY_ = 12;\\nuint8 constant _6_MONTHLY_ = 13;\\nuint8 constant _360_DAILY_ = 14;\\nuint8 constant _ANNUALLY_ = 15;\\n\\n/* ------------------------------------------------ *\\n *               FIR Interval Multipliers           *\\n * ------------------------------------------------ */\\nuint256 constant _SECONDLY_MULTIPLIER_ = 1;\\nuint256 constant _MINUTELY_MULTIPLIER_ = 60;\\nuint256 constant _HOURLY_MULTIPLIER_ = 60 * 60;\\nuint256 constant _DAILY_MULTIPLIER_ = 60 * 60 * 24;\\nuint256 constant _WEEKLY_MULTIPLIER_ = 60 * 60 * 24 * 7;\\nuint256 constant _2_WEEKLY_MULTIPLIER_ = 60 * 60 * 24 * 7 * 2;\\nuint256 constant _4_WEEKLY_MULTIPLIER_ = 60 * 60 * 24 * 7 * 4;\\nuint256 constant _6_WEEKLY_MULTIPLIER_ = 60 * 60 * 24 * 7 * 6;\\nuint256 constant _8_WEEKLY_MULTIPLIER_ = 60 * 60 * 24 * 7 * 8;\\nuint256 constant _360_DAILY_MULTIPLIER_ = 60 * 60 * 24 * 360;\\n\",\"keccak256\":\"0xff26ca73af5ce6b9cc6014706d189c58007f73731a32a59580fd9d1e02cb8027\",\"license\":\"MIT\"},\"contracts/domain/LoanContractTermMaps.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n/* ------------------------------------------------ *\\n *           Packed Debt Term Mappings              *\\n *-------------------------------------------*/\\nuint256 constant _LOAN_STATE_MASK_ =       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0;\\nuint256 constant _LOAN_STATE_MAP_ =        0x000000000000000000000000000000000000000000000000000000000000000F;\\nuint256 constant _FIR_INTERVAL_MASK_ =     0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0F;\\nuint256 constant _FIR_INTERVAL_MAP_ =      0x00000000000000000000000000000000000000000000000000000000000000F0;\\nuint256 constant _FIR_MASK_ =              0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FF;\\nuint256 constant _FIR_MAP_ =               0x000000000000000000000000000000000000000000000000000000000000FF00;\\nuint256 constant _LOAN_START_MASK_ =       0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFF;\\nuint256 constant _LOAN_START_MAP_ =        0x0000000000000000000000000000000000000000000000000000FFFFFFFF0000;\\nuint256 constant _LOAN_DURATION_MASK_ =    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFF;\\nuint256 constant _LOAN_DURATION_MAP_ =     0x00000000000000000000000000000000000000000000FFFFFFFF000000000000;\\nuint256 constant _IS_FIXED_MASK_ =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0FFFFFFFFFFFFFFFFFFFF;\\nuint256 constant _IS_FIXED_MAP_ =          0x0000000000000000000000000000000000000000000F00000000000000000000;\\nuint256 constant _COMMITAL_MASK_ =         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFF;\\nuint256 constant _COMMITAL_MAP_ =          0x00000000000000000000000000000000000000000FF000000000000000000000;\\nuint256 constant _LENDER_ROYALTIES_MASK_ = 0xFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\nuint256 constant _LENDER_ROYALTIES_MAP_ =  0x00FF000000000000000000000000000000000000000000000000000000000000;\\nuint256 constant _LOAN_COUNT_MASK_ =       0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\nuint256 constant _LOAN_COUNT_MAP_ =        0xFF00000000000000000000000000000000000000000000000000000000000000;\\nuint256 constant _CLEANUP_MASK_ =          0xFFFF0000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFF;\\n\\nuint8 constant _LOAN_STATE_POS_ = 0;\\nuint8 constant _FIR_INTERVAL_POS_ = 4;\\nuint8 constant _FIR_POS_ = 8;\\nuint8 constant _LOAN_START_POS_ = 16;\\nuint8 constant _LOAN_DURATION_POS_ = 48;\\nuint8 constant _IS_FIXED_POS_ = 80;\\nuint8 constant _COMMITAL_POS_ = 84;\\nuint8 constant _LENDER_ROYALTIES_POS_ = 240;\\nuint8 constant _LOAN_COUNT_POS_ = 248;\\n\",\"keccak256\":\"0x049c6fb78ce1cff66ec933608058fd25fe5568c40d6fdd5f3d9dc85670d08788\",\"license\":\"MIT\"},\"contracts/libraries/LibLoanContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"../domain/LoanContractFIRIntervals.sol\\\";\\nimport \\\"../domain/LoanContractTermMaps.sol\\\";\\n\\nimport \\\"../abdk-libraries-solidity/ABDKMath64x64.sol\\\";\\n\\nlibrary LibLoanContractSigning {\\n    struct ContractTerms {\\n        uint256 firInterval;\\n        uint8 fixedInterestRate;\\n        uint8 isFixed;\\n        uint8 commital;\\n        uint128 principal;\\n        uint32 gracePeriod;\\n        uint32 duration;\\n        uint32 termsExpiry;\\n        uint8 lenderRoyalties;\\n    }\\n\\n    function createContractTerms(\\n        uint8 _firInterval,\\n        uint8 _fixedInterestRate,\\n        uint8 _isFixed,\\n        uint8 _commital,\\n        uint32 _gracePeriod,\\n        uint32 _duration,\\n        uint32 _termsExpiry,\\n        uint8 _lenderRoyalties\\n    ) public pure returns (bytes32 _contractTerms) {\\n        assembly {\\n            mstore(0x20, _firInterval)\\n            mstore(0x1f, _fixedInterestRate)\\n\\n            switch eq(_isFixed, 0x01)\\n            case true {\\n                mstore(0x1e, add(0x65, _commital))\\n            }\\n            case false {\\n                mstore(0x1e, _commital)\\n            }\\n\\n            mstore(0x0d, _gracePeriod)\\n            mstore(0x09, _duration)\\n            mstore(0x05, _termsExpiry)\\n            mstore(0x01, _lenderRoyalties)\\n\\n            _contractTerms := mload(0x20)\\n        }\\n    }\\n\\n    function recoverSigner(\\n        uint256 _principal,\\n        bytes32 _contractTerms,\\n        address _collateralAddress,\\n        uint256 _collateralId,\\n        uint256 _collateralNonce,\\n        bytes memory _signature\\n    ) public pure returns (address) {\\n        bytes32 _message = prefixed(\\n            keccak256(\\n                abi.encode(\\n                    _principal,\\n                    _contractTerms,\\n                    _collateralAddress,\\n                    _collateralId,\\n                    _collateralNonce\\n                )\\n            )\\n        );\\n\\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(_signature);\\n\\n        return ecrecover(_message, v, r, s);\\n    }\\n\\n    function hashMessage(\\n        uint256 _principal,\\n        bytes32 _contractTerms,\\n        address _collateralAddress,\\n        uint256 _collateralId,\\n        uint256 _collateralNonce\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    _principal,\\n                    _contractTerms,\\n                    _collateralAddress,\\n                    _collateralId,\\n                    _collateralNonce\\n                )\\n            );\\n    }\\n\\n    function prefixed(bytes32 _hash) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _hash)\\n            );\\n    }\\n\\n    function splitSignature(\\n        bytes memory _signature\\n    ) public pure returns (uint8 v, bytes32 r, bytes32 s) {\\n        assembly {\\n            r := mload(add(_signature, 32))\\n            s := mload(add(_signature, 64))\\n            v := byte(0, mload(add(_signature, 96)))\\n        }\\n    }\\n}\\n\\nlibrary LibLoanContractIndexer {\\n    function getBorrowerTokenId(uint256 _debtId) public pure returns (uint256) {\\n        return (2 * _debtId) + 1;\\n    }\\n\\n    function getLenderTokenId(uint256 _debtId) public pure returns (uint256) {\\n        return (2 * _debtId);\\n    }\\n}\\n\\nlibrary LibLoanContractTerms {\\n    struct ContractTerms {\\n        uint256 loanState;\\n        uint256 firInterval;\\n        uint256 fixedInterestRate;\\n        uint256 loanStart;\\n        uint256 loanDuration;\\n        uint256 loanCommital;\\n        uint256 loanCommitalTime;\\n        uint256 loanClose;\\n        uint256 isFixed;\\n        uint256 lenderRoyalties;\\n        uint256 activeLoanCount;\\n    }\\n\\n    function loanState(\\n        bytes32 _contractTerms\\n    ) public pure returns (uint256 _loanState) {\\n        uint8 __loanState;\\n\\n        assembly {\\n            __loanState := and(_contractTerms, _LOAN_STATE_MAP_)\\n        }\\n\\n        unchecked {\\n            _loanState = __loanState;\\n        }\\n    }\\n\\n    function firInterval(\\n        bytes32 _contractTerms\\n    ) public pure returns (uint256 _firInterval) {\\n        uint8 __firInterval;\\n\\n        assembly {\\n            __firInterval := shr(\\n                _FIR_INTERVAL_POS_,\\n                and(_contractTerms, _FIR_INTERVAL_MAP_)\\n            )\\n        }\\n\\n        unchecked {\\n            _firInterval = __firInterval;\\n        }\\n    }\\n\\n    function fixedInterestRate(\\n        bytes32 _contractTerms\\n    ) public pure returns (uint256 _fixedInterestRate) {\\n        bytes32 __fixedInterestRate;\\n\\n        assembly {\\n            __fixedInterestRate := shr(\\n                _FIR_POS_,\\n                and(_contractTerms, _FIR_MAP_)\\n            )\\n        }\\n\\n        unchecked {\\n            _fixedInterestRate = uint256(__fixedInterestRate);\\n        }\\n    }\\n\\n    function loanLastChecked(\\n        bytes32 _contractTerms\\n    ) external pure returns (uint256) {\\n        return loanStart(_contractTerms);\\n    }\\n\\n    function loanStart(\\n        bytes32 _contractTerms\\n    ) public pure returns (uint256 _loanStart) {\\n        uint32 __loanStart;\\n\\n        assembly {\\n            __loanStart := shr(\\n                _LOAN_START_POS_,\\n                and(_contractTerms, _LOAN_START_MAP_)\\n            )\\n        }\\n\\n        unchecked {\\n            _loanStart = __loanStart;\\n        }\\n    }\\n\\n    function loanDuration(\\n        bytes32 _contractTerms\\n    ) public pure returns (uint256 _loanDuration) {\\n        uint32 __loanDuration;\\n\\n        assembly {\\n            __loanDuration := shr(\\n                _LOAN_DURATION_POS_,\\n                and(_contractTerms, _LOAN_DURATION_MAP_)\\n            )\\n        }\\n\\n        unchecked {\\n            _loanDuration = __loanDuration;\\n        }\\n    }\\n\\n    function loanCommital(\\n        bytes32 _contractTerms\\n    ) public pure returns (uint256 _loanCommital) {\\n        uint32 __loanCommital;\\n\\n        assembly {\\n            __loanCommital := shr(\\n                _COMMITAL_POS_,\\n                and(_contractTerms, _COMMITAL_MAP_)\\n            )\\n        }\\n\\n        unchecked {\\n            _loanCommital = __loanCommital;\\n        }\\n    }\\n\\n    function loanCommitalTime(\\n        bytes32 _contractTerms\\n    ) public pure returns (uint256) {\\n        int128 _loanStart = ABDKMath64x64.fromUInt(loanStart(_contractTerms));\\n        int128 _loanDuration = ABDKMath64x64.fromUInt(\\n            loanDuration(_contractTerms)\\n        );\\n        int128 _ratio = ABDKMath64x64.divu(loanCommital(_contractTerms), 100);\\n        int128 _commitalPeriod = ABDKMath64x64.mul(_loanDuration, _ratio);\\n        int128 _commitalTime = ABDKMath64x64.add(_loanStart, _commitalPeriod);\\n\\n        return ABDKMath64x64.toUInt(_commitalTime);\\n    }\\n\\n    function isFixed(\\n        bytes32 _contractTerms\\n    ) public pure returns (uint256 _isFixed) {\\n        uint32 __isFixed;\\n\\n        assembly {\\n            __isFixed := shr(\\n                _IS_FIXED_POS_,\\n                and(_contractTerms, _IS_FIXED_MAP_)\\n            )\\n        }\\n\\n        unchecked {\\n            _isFixed = __isFixed;\\n        }\\n    }\\n\\n    function loanClose(\\n        bytes32 _contractTerms\\n    ) public pure returns (uint256 _loanClose) {\\n        uint32 __loanClose;\\n\\n        assembly {\\n            __loanClose := add(\\n                shr(_LOAN_START_POS_, and(_contractTerms, _LOAN_START_MAP_)),\\n                shr(\\n                    _LOAN_DURATION_POS_,\\n                    and(_contractTerms, _LOAN_DURATION_MAP_)\\n                )\\n            )\\n        }\\n\\n        unchecked {\\n            _loanClose = __loanClose;\\n        }\\n    }\\n\\n    function lenderRoyalties(\\n        bytes32 _contractTerms\\n    ) public pure returns (uint256 _lenderRoyalties) {\\n        assembly {\\n            _lenderRoyalties := shr(\\n                _LENDER_ROYALTIES_POS_,\\n                and(_contractTerms, _LENDER_ROYALTIES_MAP_)\\n            )\\n        }\\n    }\\n\\n    function activeLoanCount(\\n        bytes32 _contractTerms\\n    ) public pure returns (uint256 _activeLoanCount) {\\n        uint8 __activeLoanCount;\\n\\n        assembly {\\n            __activeLoanCount := shr(\\n                _LOAN_COUNT_POS_,\\n                and(_contractTerms, _LOAN_COUNT_MAP_)\\n            )\\n        }\\n\\n        unchecked {\\n            _activeLoanCount = __activeLoanCount;\\n        }\\n    }\\n}\\n\\nlibrary LibLoanContractInterest {\\n    function compoundWithTopoff(\\n        uint256 _principal,\\n        uint256 _ratio,\\n        uint256 _n\\n    ) public pure returns (uint256) {\\n        return\\n            compound(_principal, _ratio, _n) + topoff(_principal, _ratio, _n);\\n    }\\n\\n    function compound(\\n        uint256 _principal,\\n        uint256 _ratio,\\n        uint256 _n\\n    ) public pure returns (uint256) {\\n        return\\n            ABDKMath64x64.mulu(\\n                pow(\\n                    ABDKMath64x64.add(\\n                        ABDKMath64x64.fromUInt(1),\\n                        ABDKMath64x64.divu(_ratio, 100)\\n                    ),\\n                    _n\\n                ),\\n                _principal\\n            );\\n    }\\n\\n    function pow(int128 _x, uint256 _n) public pure returns (int128) {\\n        int128 _r = ABDKMath64x64.fromUInt(1);\\n\\n        while (_n > 0) {\\n            if (_n % 2 == 1) {\\n                _r = ABDKMath64x64.mul(_r, _x);\\n                _n -= 1;\\n            } else {\\n                _x = ABDKMath64x64.mul(_x, _x);\\n                _n /= 2;\\n            }\\n        }\\n\\n        return _r;\\n    }\\n\\n    // Topoff to account for small inaccuracies in compound calculations\\n    function topoff(\\n        uint256 _totalDebt,\\n        uint256 _fixedInterestRate,\\n        uint256 _firIntervals\\n    ) public pure returns (uint256) {\\n        return\\n            _fixedInterestRate == 100 ? 0 : _fixedInterestRate >= 10\\n                ? _firIntervals == 1 && _totalDebt >= 10\\n                    ? 1\\n                    : _totalDebt >= 1000\\n                    ? (_totalDebt / (10 ** 21)) >= 1 ? 10 : 1\\n                    : 0\\n                : _fixedInterestRate == 1\\n                ? _firIntervals == 1 && _totalDebt >= 100\\n                    ? (_totalDebt / (10 ** 21)) >= 1 ? 10 : 1\\n                    : 0\\n                : 0;\\n    }\\n}\\n\",\"keccak256\":\"0x61ff945e4c1ea5f23d2bf6ab7fefd1d8345f972ef6d2cd201e386922025ab428\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6105d9610035600b8282823980515f1a60731461002957634e487b7160e01b5f525f60045260245ffd5b305f52607381538281f3fe7300000000000000000000000000000000000000003014608060405260043610610055575f3560e01c80636d8866f1146100595780637990fe961461007f578063ae581bc214610092578063f3c85eba146100b8575b5f80fd5b61006c6100673660046104d7565b6100cb565b6040519081526020015b60405180910390f35b61006c61008d3660046104d7565b6100f4565b6100a56100a0366004610500565b610191565b604051600f9190910b8152602001610076565b61006c6100c63660046104d7565b6101f6565b5f6100d78484846100f4565b6100e28585856101f6565b6100ec9190610543565b949350505050565b5f8260641461018457600a8310156101585782600114610114575f610186565b816001148015610125575060648410155b61012f575f610186565b6001610144683635c9adc5dea000008661056a565b1015610151576001610186565b600a610186565b8160011480156101695750600a8410155b61017d576103e884101561012f575f610186565b6001610186565b5f5b60ff16949350505050565b5f8061019d6001610226565b90505b82156101ed576101b160028461057d565b6001036101d6576101c28185610242565b90506101cf600184610590565b92506101a0565b6101e08485610242565b93506101cf60028461056a565b90505b92915050565b5f6100ec61022061021a61020a6001610226565b6102158760646102ad565b6102e2565b84610191565b85610314565b5f677fffffffffffffff82111561023b575f80fd5b5060401b90565b5f600f83810b9083900b0260401d60016001607f1b0319811280159061026f575060016001607f1b038113155b6101ed5760405162461bcd60e51b81526004016102a49060208082526004908201526319985a5b60e21b604082015260600190565b60405180910390fd5b5f815f036102b9575f80fd5b5f6102c48484610378565b905060016001607f1b036001600160801b03821611156101ed575f80fd5b5f600f83810b9083900b0160016001607f1b0319811280159061030c575060016001607f1b038113155b6101ed575f80fd5b5f815f0361032357505f6101f0565b5f83600f0b1215610332575f80fd5b600f83900b6001600160801b038316810260401c90608084901c026001600160c01b03811115610360575f80fd5b60401b8119811115610370575f80fd5b019392505050565b5f815f03610384575f80fd5b5f6001600160c01b0384116103ae5782604085901b816103a6576103a6610556565b0490506104c4565b60c084811c64010000000081106103c7576020918201911c5b6201000081106103d9576010918201911c5b61010081106103ea576008918201911c5b601081106103fa576004918201911c5b6004811061040a576002918201911c5b60028110610419576001820191505b60bf820360018603901c6001018260ff0387901b8161043a5761043a610556565b0492506001600160801b03831115610450575f80fd5b608085901c83026001600160801b038616840260c088901c604089901b8281101561047c576001820391505b608084901b92900382811015610493576001820391505b829003608084901c82146104a85760016104b9565b8881816104b7576104b7610556565b045b870196505050505050505b6001600160801b038111156101ed575f80fd5b5f805f606084860312156104e9575f80fd5b505081359360208301359350604090920135919050565b5f8060408385031215610511575f80fd5b823580600f0b8114610521575f80fd5b946020939093013593505050565b634e487b7160e01b5f52601160045260245ffd5b808201808211156101f0576101f061052f565b634e487b7160e01b5f52601260045260245ffd5b5f8261057857610578610556565b500490565b5f8261058b5761058b610556565b500690565b818103818111156101f0576101f061052f56fea2646970667358221220902ba24db1b8a2f70702907b9c7912f3cd14fac107cc1f0294cb4d0da3a5d19564736f6c63430008140033",
  "deployedBytecode": "0x7300000000000000000000000000000000000000003014608060405260043610610055575f3560e01c80636d8866f1146100595780637990fe961461007f578063ae581bc214610092578063f3c85eba146100b8575b5f80fd5b61006c6100673660046104d7565b6100cb565b6040519081526020015b60405180910390f35b61006c61008d3660046104d7565b6100f4565b6100a56100a0366004610500565b610191565b604051600f9190910b8152602001610076565b61006c6100c63660046104d7565b6101f6565b5f6100d78484846100f4565b6100e28585856101f6565b6100ec9190610543565b949350505050565b5f8260641461018457600a8310156101585782600114610114575f610186565b816001148015610125575060648410155b61012f575f610186565b6001610144683635c9adc5dea000008661056a565b1015610151576001610186565b600a610186565b8160011480156101695750600a8410155b61017d576103e884101561012f575f610186565b6001610186565b5f5b60ff16949350505050565b5f8061019d6001610226565b90505b82156101ed576101b160028461057d565b6001036101d6576101c28185610242565b90506101cf600184610590565b92506101a0565b6101e08485610242565b93506101cf60028461056a565b90505b92915050565b5f6100ec61022061021a61020a6001610226565b6102158760646102ad565b6102e2565b84610191565b85610314565b5f677fffffffffffffff82111561023b575f80fd5b5060401b90565b5f600f83810b9083900b0260401d60016001607f1b0319811280159061026f575060016001607f1b038113155b6101ed5760405162461bcd60e51b81526004016102a49060208082526004908201526319985a5b60e21b604082015260600190565b60405180910390fd5b5f815f036102b9575f80fd5b5f6102c48484610378565b905060016001607f1b036001600160801b03821611156101ed575f80fd5b5f600f83810b9083900b0160016001607f1b0319811280159061030c575060016001607f1b038113155b6101ed575f80fd5b5f815f0361032357505f6101f0565b5f83600f0b1215610332575f80fd5b600f83900b6001600160801b038316810260401c90608084901c026001600160c01b03811115610360575f80fd5b60401b8119811115610370575f80fd5b019392505050565b5f815f03610384575f80fd5b5f6001600160c01b0384116103ae5782604085901b816103a6576103a6610556565b0490506104c4565b60c084811c64010000000081106103c7576020918201911c5b6201000081106103d9576010918201911c5b61010081106103ea576008918201911c5b601081106103fa576004918201911c5b6004811061040a576002918201911c5b60028110610419576001820191505b60bf820360018603901c6001018260ff0387901b8161043a5761043a610556565b0492506001600160801b03831115610450575f80fd5b608085901c83026001600160801b038616840260c088901c604089901b8281101561047c576001820391505b608084901b92900382811015610493576001820391505b829003608084901c82146104a85760016104b9565b8881816104b7576104b7610556565b045b870196505050505050505b6001600160801b038111156101ed575f80fd5b5f805f606084860312156104e9575f80fd5b505081359360208301359350604090920135919050565b5f8060408385031215610511575f80fd5b823580600f0b8114610521575f80fd5b946020939093013593505050565b634e487b7160e01b5f52601160045260245ffd5b808201808211156101f0576101f061052f565b634e487b7160e01b5f52601260045260245ffd5b5f8261057857610578610556565b500490565b5f8261058b5761058b610556565b500690565b818103818111156101f0576101f061052f56fea2646970667358221220902ba24db1b8a2f70702907b9c7912f3cd14fac107cc1f0294cb4d0da3a5d19564736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}